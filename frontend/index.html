<!DOCTYPE html>
<html>
  <head>
    <title>Tiny frontend for Crypto Zombies</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/web3@1.3.4/dist/web3.min.js"></script>

    <script>
      // todo: contract consts
      const cryptoZombiesAddress = "0xA7cf5704e00ca9a53b24737db052ED69B68719ac"
      const cryptoZombiesAbi = [ { "inputs": [ { "internalType": "address", "name": "_linkTokenAddress", "type": "address" }, { "internalType": "bytes32", "name": "_keyHash", "type": "bytes32" }, { "internalType": "address", "name": "_vrfCoordinatorAddress", "type": "address" }, { "internalType": "uint256", "name": "_fee", "type": "uint256" } ], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "internalType": "bytes32", "name": "requestId", "type": "bytes32" }, { "indexed": false, "internalType": "string", "name": "zombieName", "type": "string" } ], "name": "CreateRandomZombieRequest", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": false, "internalType": "uint256", "name": "zombieId", "type": "uint256" }, { "indexed": false, "internalType": "string", "name": "name", "type": "string" }, { "indexed": false, "internalType": "uint256", "name": "dna", "type": "uint256" } ], "name": "NewZombie", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "OwnershipTransferred", "type": "event" }, { "inputs": [], "name": "fee", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "isOwner", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "keyHash", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "owner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "bytes32", "name": "requestId", "type": "bytes32" }, { "internalType": "uint256", "name": "randomness", "type": "uint256" } ], "name": "rawFulfillRandomness", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "name": "requestIdToAddress", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "zombieToOwner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "zombies", "outputs": [ { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "uint256", "name": "dna", "type": "uint256" }, { "internalType": "uint32", "name": "level", "type": "uint32" }, { "internalType": "uint32", "name": "readyTime", "type": "uint32" }, { "internalType": "uint16", "name": "winCount", "type": "uint16" }, { "internalType": "uint16", "name": "lossCount", "type": "uint16" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "string", "name": "_zombieName", "type": "string" } ], "name": "createRandomZombieRequest", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "kill", "outputs": [], "stateMutability": "nonpayable", "type": "function" } ]

      window.userWeb3 = new Web3(window.ethereum)  // coz may be user already connect his metamask to www
      // the document use cookie to identify if user loggedIn or desired to logout
      // coz of in metamask to true logout user should do so with metamask!
      const metaMaskLoggedInCookie = "metaMaskLoggedIn=true"
      const metaMaskLoggedOutCookie = "metaMaskLoggedIn=false"
      let currentUserAddressGlobal = ""
      let cryptoZombiesContractGlobal = null

      function isMetaMaskLoggedInCookie() {
        return !!document.cookie.split(';').filter((item) => item.includes(metaMaskLoggedInCookie)).length;
      }

      function deleteMetaMaskLoggedInCookie() {
        document.cookie = metaMaskLoggedOutCookie;
      }

      const ethEnabled = async () => {
        if (typeof window.ethereum !== 'undefined') {
          console.log('MetaMask is installed!');
          return true
        }
        return false
      }

      async function loginWithMetaMask() {
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' })
          .catch((e) => {
            console.error('could not login with metamask', e.message)
            return
          })
        if (!accounts) {
          return
        }
        window.userWeb3 = new Web3(window.ethereum)
        document.cookie = metaMaskLoggedInCookie
        console.log("new web3 created", window.userWeb3)
      }

      // first of all in the app should be logic about metamask login
      let authHtml = "";

      const render = async () => {

        // todo: init subscribers
        ethereum.on('accountsChanged', render);
        ethereum.on('disconnect', render);

        if (!await ethEnabled()) {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info">MetaMask is not installed or not enabled. Check <a href="https://www.geeksforgeeks.org/how-to-install-and-use-metamask-on-google-chrome/" target="_blank">instruction</a>.</div>
              <button id="loginButtonId" disabled onclick="() => {}">Login is not enabled</button>
            </div>
          `;
        } else {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info">Proceed login with Meta Mask.</div>
              <button id="loginButtonId" onclick="handleLogin()">Login</button>
            </div>
          `;
        }

        const accounts = await window.userWeb3.eth.getAccounts()
            .catch((e) => {
              console.error(e.message)
              return
            })
        cryptoZombiesContractGlobal = new window.userWeb3.eth.Contract(cryptoZombiesAbi, cryptoZombiesAddress);

        // below define html blocks which will be in use on success login
        let userHtml = "";
        let createRandomZombieHtml = "";
        const target = document.querySelector("#app");

        if (accounts.length && isMetaMaskLoggedInCookie()) {  // check both: metamask provider readiness & that user want to be logged in
          const network = await window.userWeb3.eth.net.getNetworkType();
          currentUserAddressGlobal = accounts[0];
          const userBalance = window.userWeb3.utils.fromWei(
            await window.userWeb3.eth.getBalance(currentUserAddressGlobal)
          );

          console.log(cryptoZombiesContractGlobal)
          console.log(currentUserAddressGlobal)

          // collect info about zombies
          // todo: ...

          authHtml = `
            <div class="container">
              <h1>Logout</h1>
              <div class="info">The true disconnect functionality is entirely in the user's hands due to security and privacy concerns, but for user-convenience you can check a button below.</div>
              <button onclick="handleLogout()">Logout</button>
            </div>
          `;
          userHtml = `
            <div class="container">
              <h1>Crypto Profile</h1>
              <div class="info">
                <a href="https://testnet.bscscan.com/address/${currentUserAddressGlobal}" target="_blank">${currentUserAddressGlobal}</a>
              </div>
              <h1>Network</h1>
              <div class="info">${network}</div>
              <h1>Balance</h1>
              <div class="info">${userBalance} ETH</div>
            </div>
          `;
          createRandomZombieHtml = `
            <div class="container">
              <h1>Create You First Zombie</h1>
              <div class="info">You start game with first random zombie.</div>
              <form onsubmit="handleCreateRandomZombie(event)">
                <input type="text" name="zombieName" class="full-width" required="required" placeholder="Your zombie name"/>
                <button id="btn-create-random-zombie" type="submit">Create random zombie</button>
              </form>

            </div>
          `;
        }
        target.innerHTML =
          authHtml + userHtml + createRandomZombieHtml;
      };

      const handleCreateRandomZombie = async (e) => {
        e.preventDefault();
        const zombieName = new FormData(e.target).get("zombieName");
        console.log(zombieName)
        console.log(cryptoZombiesContractGlobal)
        console.log(currentUserAddressGlobal)

        if (cryptoZombiesContractGlobal && currentUserAddressGlobal && zombieName) {
          const btnSendTxn = document.getElementById("btn-create-random-zombie");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Creating...";

          const result = await cryptoZombiesContractGlobal.methods
            .createRandomZombieRequest(zombieName)
            .send({
              from: currentUserAddressGlobal,
              gas: 1500000,
              gasPrice: '30000000000'})  // todo
            .on("receipt", function(receipt) {
              console.log("Chain accepted creation, wait for oracles for randomizing...");
              // getZombiesByOwner(userAccount).then(displayZombies);
            })
            .on("error", function(error) {
              console.log("Transaction error:" + error);
            });
          console.log(result)
          render();
        }
      }

      const handleTryCrossChainTransfer = async (e) => {
        e.preventDefault();
        const nftContract = new FormData(e.target).get("nftContract");
        const nftToken = new FormData(e.target).get("nftToken");

        const toChainId = new FormData(e.target).get("toChainId");  // int for chain, e.g. rinkeby: 4

        if (nftContract && nftToken && toChainId) {
          const btnSendTxn = document.getElementById("btn-send-transfer");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Transferring...";
          console.log('send contract', nftContract)
          console.log('send token', nftToken)
          console.log('send chain', toChainId)

          const userAddress = (await window.userWeb3.eth.getAccounts())[0];
          let transferContract = new window.userWeb3.eth.Contract(
              erc721TransferAbi,
              erc721TransferAddress
          );

          const result = await transferContract.methods
            .tryCrossChainTransfer(toChainId, nftContract, nftToken)
            .send({
              // value: '10000000000000000',  // todo
              from: userAddress,
              gas: 1500000,
              gasPrice: '30000000000'})  // todo
          console.log("result of transferring: ", result);
          render();
        }
      };

      const handleLogin = async () => {
        await loginWithMetaMask();
        render()
      }

      const handleLogout = async () => {
        deleteMetaMaskLoggedInCookie();
        render();
      };
    </script>
  </head>

  <body onload="render()">
    <div id="app">
      <div class="container">Loading (awaiting MetaMask login)...</div>
    </div>
  </body>

</html>
