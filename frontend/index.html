<!DOCTYPE html>
<html>
  <head>
    <title>Tiny frontend for Crypto Zombies</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.3.4/dist/web3.min.js"></script>

    <script>
      // todo: contract consts
      const cryptoZombiesAddress = "0xb34e1444a2A06683A8ABc47AC4F0b159EAb2844a"
      const cryptoZombiesAbi = [ { "inputs": [ { "internalType": "address", "name": "_linkTokenAddress", "type": "address" }, { "internalType": "bytes32", "name": "_keyHash", "type": "bytes32" }, { "internalType": "address", "name": "_vrfCoordinatorAddress", "type": "address" }, { "internalType": "uint256", "name": "_fee", "type": "uint256" } ], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": false, "internalType": "bytes32", "name": "requestId", "type": "bytes32" }, { "indexed": false, "internalType": "string", "name": "zombieName", "type": "string" } ], "name": "CreateRandomZombieRequest", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": false, "internalType": "uint256", "name": "zombieId", "type": "uint256" }, { "indexed": false, "internalType": "string", "name": "name", "type": "string" }, { "indexed": false, "internalType": "uint256", "name": "dna", "type": "uint256" }, { "indexed": false, "internalType": "address", "name": "owner", "type": "address" } ], "name": "NewZombie", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "OwnershipTransferred", "type": "event" }, { "inputs": [ { "internalType": "string", "name": "_zombieName", "type": "string" } ], "name": "createRandomZombieRequest", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "fee", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "uint256", "name": "_zombieId", "type": "uint256" }, { "internalType": "uint256", "name": "_kittyId", "type": "uint256" } ], "name": "feedOnKitty", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "isOwner", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "keyHash", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "kill", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "bytes32", "name": "requestId", "type": "bytes32" }, { "internalType": "uint256", "name": "randomness", "type": "uint256" } ], "name": "rawFulfillRandomness", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "name": "requestIdToAddress", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "address", "name": "_address", "type": "address" } ], "name": "setKittyContractAddress", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "zombieToOwner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "zombies", "outputs": [ { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "uint256", "name": "dna", "type": "uint256" }, { "internalType": "uint32", "name": "level", "type": "uint32" }, { "internalType": "uint32", "name": "readyTime", "type": "uint32" }, { "internalType": "uint16", "name": "winCount", "type": "uint16" }, { "internalType": "uint16", "name": "lossCount", "type": "uint16" } ], "stateMutability": "view", "type": "function", "constant": true }, { "inputs": [], "name": "withdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_fee", "type": "uint256" } ], "name": "setLevelUpFee", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_zombieId", "type": "uint256" } ], "name": "levelUp", "outputs": [], "stateMutability": "payable", "type": "function", "payable": true }, { "inputs": [ { "internalType": "uint256", "name": "_zombieId", "type": "uint256" }, { "internalType": "string", "name": "_newName", "type": "string" } ], "name": "changeName", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_zombieId", "type": "uint256" }, { "internalType": "uint256", "name": "_newDna", "type": "uint256" } ], "name": "changeDna", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "_owner", "type": "address" } ], "name": "getZombiesByOwner", "outputs": [ { "internalType": "uint256[]", "name": "", "type": "uint256[]" } ], "stateMutability": "view", "type": "function", "constant": true } ]

      window.userWeb3 = new Web3(window.ethereum)  // coz may be user already connect his metamask to www
      // the document use cookie to identify if user loggedIn or desired to logout
      // coz of in metamask to true logout user should do so with metamask!
      const metaMaskLoggedInCookie = "metaMaskLoggedIn=true"
      const metaMaskLoggedOutCookie = "metaMaskLoggedIn=false"
      let currentUserAddressGlobal = ""
      let cryptoZombiesContractGlobal = null

      function isMetaMaskLoggedInCookie() {
        return !!document.cookie.split(';').filter((item) => item.includes(metaMaskLoggedInCookie)).length;
      }

      function deleteMetaMaskLoggedInCookie() {
        document.cookie = metaMaskLoggedOutCookie;
      }

      const ethEnabled = async () => {
        if (typeof window.ethereum !== 'undefined') {
          console.log('MetaMask is installed!');
          return true
        }
        return false
      }

      async function loginWithMetaMask() {
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' })
          .catch((e) => {
            console.error('could not login with metamask', e.message)
            return
          })
        if (!accounts) {
          return
        }
        window.userWeb3 = new Web3(window.ethereum)
        document.cookie = metaMaskLoggedInCookie
        console.log("new web3 created", window.userWeb3)
      }

      // first of all in the app should be logic about metamask login
      let authHtml = "";

      // --- zombie functions block start ---
      // function below works through jquery
      function displayZombies(ids) {
        $("#renderedZombies").empty();
        for (id in ids) {
          let _id = id
          getZombieDetails(id)
          .then(function(zombie) {
            $("#renderedZombies").append(`
            <div class="zombie" style="text-align: left">
              <ul>
                <li>Id: ${_id}</li>
                <li>Name: ${zombie.name}</li>
                <li>DNA: ${zombie.dna}</li>
                <li>Level: ${zombie.level}</li>
                <li>Wins: ${zombie.winCount}</li>
                <li>Losses: ${zombie.lossCount}</li>
                <li>Ready Time: ${zombie.readyTime}</li>
              </ul>
            </div>`);
          });
        }
      }

      function getZombieDetails(id) {
        return cryptoZombiesContractGlobal.methods.zombies(id).call()
      }

      function zombieToOwner(id) {
        return cryptoZombiesContractGlobal.methods.zombieToOwner(id).call()
      }

      function getZombiesByOwner(owner) {
        return cryptoZombiesContractGlobal.methods.getZombiesByOwner(owner).call()
      }
      // --- zombie functions block end ---

      const render = async () => {

        // Network evm subscribers
        ethereum.on('accountsChanged', render);
        ethereum.on('disconnect', render);

        if (!await ethEnabled()) {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info">MetaMask is not installed or not enabled. Check <a href="https://www.geeksforgeeks.org/how-to-install-and-use-metamask-on-google-chrome/" target="_blank">instruction</a>.</div>
              <button id="loginButtonId" disabled onclick="() => {}">Login is not enabled</button>
            </div>
          `;
        } else {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info" id="loginInfo">Proceed login with Meta Mask.</div>
              <button id="loginButtonId" onclick="handleLogin()">Login</button>
            </div>
          `;
        }

        const accounts = await window.userWeb3.eth.getAccounts()
            .catch((e) => {
              console.error(e.message)
              return
            })
        cryptoZombiesContractGlobal = new window.userWeb3.eth.Contract(cryptoZombiesAbi, cryptoZombiesAddress);

        // Html blocks which will be in use on success login
        let userHtml = "";
        let currentZombiesHtml= "";
        let createRandomZombieHtml = "";
        let zombieManagementHtml = "";
        let zombieContractAdminHtml = "";
        const target = document.querySelector("#app");

        if (accounts.length && isMetaMaskLoggedInCookie()) {  // check both: metamask provider readiness & that user want to be logged in
          const network = await window.userWeb3.eth.net.getNetworkType();
          currentUserAddressGlobal = accounts[0];
          const userBalance = window.userWeb3.utils.fromWei(
            await window.userWeb3.eth.getBalance(currentUserAddressGlobal)
          );

          console.log(cryptoZombiesContractGlobal)
          console.log(currentUserAddressGlobal)

          // ---- Subscribe on contract event ----
          cryptoZombiesContractGlobal.events.NewZombie({ filter: { owner: currentUserAddressGlobal } })
            .on("data", async function(event) {
              console.log('event came...')
              console.log(event.returnValues);
              render()
            })
            .on("error", console.error)
          console.log("Start listening NewZombie event...")

          authHtml = `
            <div class="container">
              <h1>Logout</h1>
              <div class="info">The true disconnect functionality is entirely in the user's hands due to security and privacy concerns, but for user-convenience you can check a button below.</div>
              <button onclick="handleLogout()">Logout</button>
            </div>
          `;
          userHtml = `
            <div class="container">
              <h1>Crypto Profile</h1>
              <div class="info">
                <a href="https://testnet.bscscan.com/address/${currentUserAddressGlobal}" target="_blank">${currentUserAddressGlobal}</a>
              </div>
              <h1>Network</h1>
              <div class="info">${network}</div>
              <h1>Balance</h1>
              <div class="info">${userBalance} ETH</div>
            </div>
          `;
          createRandomZombieHtml = `
            <div class="container">
              <h1>The First Zombie</h1>
              <div class="info">You may start game with the first random zombie. Choose a name!</div>
              <form onsubmit="handleCreateRandomZombie(event)">
                <input type="text" name="zombieName" class="full-width" required="required" placeholder="Your zombie name"/>
                <button id="btn-create-random-zombie" type="submit">Create random zombie</button>
              </form>
            </div>
          `;
          currentZombiesHtml = `
            <div class="container">
              <h1>Your Zombie Army</h1>
              <div class="info" id="renderedZombies">Loading...</div>
            </div>
          `;
          zombieManagementHtml = `
            <div class="container">
              <h1>Zombie Management</h1>
              <div class="info">You Can feed your zombie with kitty in order to create a brand-new zombie.</div>
              <form onsubmit="handleFeedOnKitty(event)">
                <input type="text" name="zombieId" class="full-width" required="required" placeholder="Zombie Id"/>
                <input type="text" name="kittyId" class="full-width" required="required" placeholder="Kitty Id"/>
                <button id="btn-feedOnKitty" type="submit">Feed</button>
              </form>
            </div>
          `;
          zombieContractAdminHtml = `
            <div class="container">
              <h1>Contract Administrator</h1>
              <div class="info">If you are an administrator you may manage the game with commands below.</div>
              <form onsubmit="handleSetKittyContractAddress(event)">
                <input type="text" name="kittyContractAddress" class="full-width" required="required" placeholder="Kitty Contract Address"/>
                <button id="btn-setKittyContractAddress" type="submit">Set</button>
              </form>
              <form onsubmit="handleSetLevelUpFee(event)">
                <input type="text" name="feeValue" class="full-width" required="required" placeholder="Fee Value"/>
                <button id="btn-setLevelUpFee" type="submit">Set</button>
              </form>
            </div>
          `;
        }
        target.innerHTML =
          userHtml + createRandomZombieHtml + currentZombiesHtml + zombieManagementHtml + zombieContractAdminHtml + authHtml;

        // ---- start functions ----
        getZombiesByOwner(currentUserAddressGlobal).then(displayZombies);
      };


      // ---- Zombie handlers ----
      const handleFeedOnKitty = async (e) => {
        e.preventDefault();
        const kittyId = new FormData(e.target).get("kittyId");
        const zombieId = new FormData(e.target).get("zombieId");

        if (cryptoZombiesContractGlobal && currentUserAddressGlobal && zombieId && kittyId) {
          const btnSendTxn = document.getElementById("btn-feedOnKitty");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Feeding...";

          await cryptoZombiesContractGlobal.methods
            .feedOnKitty(zombieId, kittyId)
            .send({
              from: currentUserAddressGlobal,
              gas: 1500000,
              gasPrice: '30000000000'})
            .on("receipt", function(receipt) {
              console.log("Set");
            })
            .on("error", function(error) {
              console.log("Transaction error:" + error);
            });
          render();
        }
      }

      const handleSetLevelUpFee = async (e) => {
        e.preventDefault();
        const feeValue = new FormData(e.target).get("feeValue");

        if (cryptoZombiesContractGlobal && currentUserAddressGlobal && feeValue) {
          const btnSendTxn = document.getElementById("btn-setLevelUpFee");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Setting...";

          await cryptoZombiesContractGlobal.methods
            .setLevelUpFee(feeValue)
            .send({
              from: currentUserAddressGlobal,
              gas: 1500000,
              gasPrice: '30000000000'})
            .on("receipt", function(receipt) {
              console.log("Set");
            })
            .on("error", function(error) {
              console.log("Transaction error:" + error);
            });
          render();
        }
      }

      const handleSetKittyContractAddress = async (e) => {
        e.preventDefault();
        const kittyContractAddress = new FormData(e.target).get("kittyContractAddress");

        if (cryptoZombiesContractGlobal && currentUserAddressGlobal && kittyContractAddress) {
          const btnSendTxn = document.getElementById("btn-setKittyContractAddress");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Setting...";

          await cryptoZombiesContractGlobal.methods
            .setKittyContractAddress(kittyContractAddress)
            .send({
              from: currentUserAddressGlobal,
              gas: 1500000,
              gasPrice: '30000000000'})
            .on("receipt", function(receipt) {
              console.log("Set");
            })
            .on("error", function(error) {
              console.log("Transaction error:" + error);
            });
          render();
        }
      }

      const handleCreateRandomZombie = async (e) => {
        e.preventDefault();
        const zombieName = new FormData(e.target).get("zombieName");
        console.log(zombieName)
        console.log(currentUserAddressGlobal)

        if (cryptoZombiesContractGlobal && currentUserAddressGlobal && zombieName) {
          const btnSendTxn = document.getElementById("btn-create-random-zombie");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Creating...";

          const result = await cryptoZombiesContractGlobal.methods
            .createRandomZombieRequest(zombieName)
            .send({
              from: currentUserAddressGlobal,
              gas: 1500000,
              gasPrice: '30000000000'})
            .on("receipt", function(receipt) {
              console.log("Chain accepted creation, wait for oracles for randomizing...");
            })
            .on("error", function(error) {
              console.log("Transaction error:" + error);
            });
          console.log(result)
          render();
        }
      }

      // ---- common handlers ----
      const handleLogin = async () => {
        await loginWithMetaMask();
        render()
      }

      const handleLogout = async () => {
        deleteMetaMaskLoggedInCookie();
        render();
      };
    </script>
  </head>

  <body onload="render()">
    <div id="app">
      <div class="container">Loading (awaiting MetaMask login)...</div>
    </div>
  </body>

</html>
